## 2025_11_22 
- project with z

## 크롬 디버깅 모드 실행 
- win + r
- chrome.exe --remote-debugging-port=9222 --user-data-dir="C:\chrome_debug_temp"

## 실행후 가상환경에서 
- python bot.py

크롤링 중 차단이 발생했을 때, 시크릿 모드나 사용 기록 삭제 후 접속이 된다면 이는 IP 차단이 아닙니다.

1. 차단 원인: 브라우저 지문(Fingerprint) 추적
서버는 단순히 IP만 보지 않습니다. 쿠키(Cookie), 로컬 스토리지, 세션 ID에 남은 봇의 '비정상적인 탐색 기록'을 식별합니다. 이 '기록'을 안고 재접속하면 서버는 즉시 봇으로 간주하여 차단합니다.

2. 해결 전략: 세션 초기화 (Identity Reset)
서버가 나를 '기존의 봇'이 아닌 '처음 온 방문자'로 인식하게 만드는 것이 핵심입니다.

세션 세탁: 코드 실행 시마다 브라우저의 모든 쿠키 및 사이트 데이터를 강제 삭제합니다.

무결성 확보: about:blank 등 빈 페이지에서 연결을 끊은 상태로 삭제를 진행합니다.

결과: 깨끗한 상태로 재접속 시, 서버는 새로운 유저로 인식하여 새 세션 ID를 발급하고 접속을 허용합니다.

Note: 이 방법으로도 해결되지 않을 경우에만 IP 차단으로 간주하여 프록시나 테더링을 사용합니다.

---
본 프로젝트는 Playwright의 동기 모드(sync_playwright)를 기반으로 개발되었습니다.
초기 모델의 느린 수집 속도를 개선하기 위해 수행한 두 가지 주요 최적화 실험과 그 결과를 기록합니다.

1. 베이스라인: 안정성 중심 모델 (Basic Stable)

초기 코드는 차단 회피와 데이터의 온전한 로딩을 위해 **"실제 사람의 행동 패턴"**을 100% 모사하는 데 집중했습니다.

리소스 로딩: 이미지, 광고 배너, 폰트 등 페이지의 모든 리소스를 차단 없이 다운로드

스크롤 방식: mouse.wheel 이벤트를 반복문으로 실행하여, 사람이 휠을 '드르륵' 굴리며 천천히 내려가는 동작 구현

문제점: 안정적이나, 상품 1개를 수집하는 데 불필요한 대기 시간이 길어 전체 효율이 낮음

2. 최적화 실험 및 결과 (Experiment & Results)

속도 개선을 위해 **'리소스 차단'**과 '스크롤 로직 변경' 두 가지 변인을 테스트했습니다.

A. 리소스 차단

route.abort()를 사용하여 이미지(.png, .jpg) 및 광고 스크립트 로딩 차단

효과 미미함 (Insignificant)
쿠팡 페이지는 텍스트 로딩이 빠르기 때문에, 이미지 다운로드 시간이 전체 병목의 핵심 원인은 아니었음.

B. 스크롤 최적화

물리적 휠(mouse.wheel) 루프 제거 → window.scrollTo JS 강제 실행

50% 시간 단축 (크리티컬한 변화가 생김)

사람 흉내를 내기 위한 '인위적인 스크롤 딜레이'가 속도 저하의 주범이었음. 이를 0.1초 만에 수행되는 JS 실행으로 대체하여 획기적인 성능 향상 확인함

3. 결론 (Conclusion)

동기 방식 크롤러에서 속도를 결정짓는 가장 큰 요소는 네트워크(다운로드) 속도가 아닌, 브라우저 인터랙션(스크롤, 대기)의 오버헤드였습니다.

따라서 최종 코드는 이미지 로딩은 허용(안정성 확보)하되, 스크롤은 자바스크립트로 강제 이동(속도 확보)**하는 하이브리드 방식을 채택했습니다.
